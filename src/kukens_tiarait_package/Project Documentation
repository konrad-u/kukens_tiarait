# Project Documentation

Here I will describe the steps I took in creating my player strategies for the Tiarait bots. 

## Step 0: Multirun automation, game state tracking
Unlike my previous programs for the SARG player, in this project I set up a Multirun run configuration (https://plugins.jetbrains.com/plugin/7248-multirun) through which I could in a single test run multiple instances of the default player NetworkClient class, making testing significantly easier. 

After setting up the project and a dummy player class, I set up the GameBoard class to imitate the server and coloring. Similar to the SARG project, I use a console print to make sure that the imitation is accurate, and that the player score countrs as well as color indications work properly. 

Once I had the test configuration and game tracking setup, I adjusted the GameBoard class to contain a 2D Array of BoardFields; this would allow me to save the fieldValue and coordinates of the BoardField, to be able to use them in later calculations *e.g. for pathfinding distances, to calculate each player's current score etc.). 

I set up a Boardfield Class with 3 integers, an x, a y and a fieldValue, which would be used to save the status of the field (either empty, a wall or painted by a player), encoded in an integer with a value 0-5.

## Step 1: Abstract Bot Class

To outline the general behaviour of any of the bots before developing specific strategies for each bot to follow, I outlined an AbstractBot class similarly to an interface to prescribe general fields and methods that each bot class would need to formulate a strategy, regardless of skill. The methods updateBotGoal() and setDirection(), as well as the constructor of the BotDirection inner class, were left empty for implementation in the concrete bot classes. 

I here started considering how I would want to go about making and using strategies, as I considered either maintaining a single goal throughout the game, updating it at regular intervals by reassessing the game board, or creating smaller goals, and, upon reaching them, creating new goals. 
I decided to go with the latter option, figuring that for testing and strategy development starting with smaller goals, and, once some set of strategies was developed, to then experiment with more sophisticated options. 



 